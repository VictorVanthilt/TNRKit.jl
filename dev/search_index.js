var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"Adachi, D.; Okubo, T. and Todo, S. (2020). Anisotropic Tensor Renormalization Group. Physical Review B 102.\n\n\n\nAdachi, D.; Okubo, T. and Todo, S. (2022). Bond-Weighted Tensor Renormalization Group. Physical Review B 105.\n\n\n\nAkiyama, S.; Meurice, Y. and Sakai, R. (2024). Tensor Renormalization Group for Fermions. Journal of Physics: Condensed Matter 36.\n\n\n\nKadoh, D.; Kuramashi, Y.; Nakamura, Y.; Sakai, R.; Takeda, S. and Yoshimura, Y. (2019). Tensor network analysis of critical coupling in two dimensional varphi^4 theory. Journal of High Energy Physics 2019, 184, arXiv:1811.12376 [hep-lat].\n\n\n\nLevin, M. and Nave, C. P. (2007). Tensor Renormalization Group Approach to Two-Dimensional Classical Lattice Models. Physical Review Letters 99.\n\n\n\nMorita, S. and Kawashima, N. (2019). Calculation of Higher-Order Moments by Higher-Order Tensor Renormalization Group. Computer Physics Communications 236, arXiv:1806.10275 [cond-mat].\n\n\n\nMorita, S. and Kawashima, N. (2025). Multi-Impurity Method for the Bond-Weighted Tensor Renormalization Group. Physical Review B 111.\n\n\n\nXie, Z. Y.; Chen, J.; Qin, M. P.; Zhu, J. W.; Yang, L. P. and Xiang, T. (2012). Coarse-Graining Renormalization by Higher-Order Singular Value Decomposition. Physical Review B 86.\n\n\n\nYang, S.; Gu, Z.-C. and Wen, X.-G. (2017). Loop Optimization for Tensor Network Renormalization. Physical Review Letters 118.\n\n\n\n","category":"section"},{"location":"lib/lib/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"lib/lib/#TNRKit.ATRG","page":"Library","title":"TNRKit.ATRG","text":"mutable struct ATRG{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}} <: TNRScheme{E, S}\n\nAnisotropic Tensor Renormalization Group\n\nConstructors\n\nATRG(T)\n\nRunning the algorithm\n\nrun!(::ATRG, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of √2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Central tensor\n\nReferences\n\nAdachi et. al. Phys. Rev. B 102 (2020)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.ATRG_3D","page":"Library","title":"TNRKit.ATRG_3D","text":"mutable struct ATRG_3D{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 4}} <: TNRScheme{E, S}\n\n3D Anisotropic Tensor Renormalization Group\n\nConstructors\n\nATRG_3D(T)\n\nRunning the algorithm\n\nrun!(::ATRG_3D, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=defualt_Finalizer, finalize_beginning=true,verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of 2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 4} where {E, S}: Central tensor\n\nReferences\n\nAdachi et. al. Phys. Rev. B 102 (2020)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.BTRG","page":"Library","title":"TNRKit.BTRG","text":"mutable struct BTRG{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}, BT<:TensorKit.AbstractTensorMap{E, S, 1, 1}} <: TNRScheme{E, S}\n\nBond-weighted Tensor Renormalization Group\n\nConstructors\n\nBTRG(T [, k=-1/2])\n\nRunning the algorithm\n\nrun!(::BTRG, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of √2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Central tensor\nS1::TensorKit.AbstractTensorMap{E, S, 1, 1} where {E, S}: Bond tensor on vertical bonds\nS2::TensorKit.AbstractTensorMap{E, S, 1, 1} where {E, S}: Bond tensor on horizontal bonds\nk::Float64: Bond weight exponent\n\nReferences\n\nAdachi et. al. Phys. Rev. B 105 (2022)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.CTM","page":"Library","title":"TNRKit.CTM","text":"        ┌───┐ ┌──┐ ┌───┐\n        │Ctl├─┤Et├─┤Ctr│\n        └─┬─┘ └┬─┘ └─┬─┘\n        ┌─┼─┐ ┌┼─┐ ┌─┼─┐\n        │El ├─┤T ├─┤Er │\n        └─┬─┘ └┬─┘ └─┬─┘\n        ┌─┼─┐ ┌┼─┐ ┌─┼─┐\n        │Cbl├─┤Eb├─┤Cbr│\n        └───┘ └──┘ └───┘\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.Finalizer","page":"Library","title":"TNRKit.Finalizer","text":"struct Finalizer{E}\n\nFinalizer for TNR schemes\n\nConstructors\n\nFinalizer(f!::Function, E::Type)\n\nA Finalizer holds a function f! that is to be applied to a TNR scheme after each step of the algorithm (and at the beginning if specified by run!(;finalize_beginning=true), which is the default behavior). The type parameter E indicates the output type of f!, which is used to create an array of the correct type to hold the outputs.\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.HOTRG","page":"Library","title":"TNRKit.HOTRG","text":"mutable struct HOTRG{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}} <: TNRScheme{E, S}\n\nHigher-Order Tensor Renormalization Group\n\nConstructors\n\nHOTRG(T)\n\nRunning the algorithm\n\nrun!(::HOTRG, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of 2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Central tensor\n\nReferences\n\nXie et. al. Phys. Rev. B 86 (2012)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.HOTRG_3D","page":"Library","title":"TNRKit.HOTRG_3D","text":"mutable struct HOTRG_3D{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 4}} <: TNRScheme{E, S}\n\n3D Higher-Order Tensor Renormalization Group\n\nConstructors\n\nHOTRG_3D(T)\n\nRunning the algorithm\n\nrun!(::HOTRG_3D, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of 2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 4} where {E, S}: Central tensor\n\nReferences\n\nXie et. al. Phys. Rev. B 86 (2012)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.ImpurityHOTRG","page":"Library","title":"TNRKit.ImpurityHOTRG","text":"mutable struct ImpurityHOTRG{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}} <: TNRScheme{E, S}\n\nSingle impurity method for Higher-Order Tensor Renormalization Group (for 2nd order)\n\nConstructors\n\nImpurityHOTRG(T, T_imp_order1_1, T_imp_order1_2, T_imp_order2)\n\nRunning the algorithm\n\nrun!(::ImpurityHOTRG, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=ImpurityHOTRG_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of 2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Cental Tensor\nT_imp_order1_1::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: +1 Type first order impurity tensor\nT_imp_order1_2::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: -1 Type first order impurity tensor\nT_imp_order2::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Second order impurity tensor\n\nReferences\n\nMorita et al 10.1016/j.cpc.2018.10.014 (2018)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.ImpurityTRG","page":"Library","title":"TNRKit.ImpurityTRG","text":"mutable struct ImpurityTRG{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}} <: TNRScheme{E, S}\n\nImpurity method for Tensor Renormalization Group\n\nConstructors\n\nImpurityTRG(T, T_imp1, T_imp2, T_imp3, T_imp4)\n\nRunning the algorithm\n\nrun!(::ImpurityTRG, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=ImpurityTRG_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of √2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Pure tensor\nT_imp1::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Impurity tensor on lattice site 1\nT_imp2::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Impurity tensor on lattice site 2\nT_imp3::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Impurity tensor on lattice site 3\nT_imp4::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Impurity tensor on lattice site 4\n\nIllustration (with p the pure tensor, and the p fills in the rest of the lattice):\n\n    p   p\n    |   |  \np---1---2---p\n    |   |\np---4---3---p\n    |   |\n    p   p\n\nReferences\n\nKadoh et. al. 10.1007/JHEP05(2019)184 (2019)\nMorita et. al. Phys. Rev. B 111 (2025)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.LoopTNR","page":"Library","title":"TNRKit.LoopTNR","text":"mutable struct LoopTNR{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}} <: TNRScheme{E, S}\n\nLoop Optimization for Tensor Network Renormalization\n\nConstructors\n\nLoopTNR(T)\nLoopTNR(TA, TB)\nLoopTNR(unitcell_2x2::Matrix{T})\n\nRunning the algorithm\n\nrun!(::LoopTNR, trunc::TensorKit.TruncationScheme, truncentanglement::TensorKit.TruncationScheme, criterion::stopcrit,\n          entanglement_criterion::stopcrit, loop_criterion::stopcrit[, finalize_beginning=true, verbosity=1])\n\nrun!(::LoopTNR, trscheme::TensorKit.TruncationScheme, criterion::stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, verbosity=1])\n\nFields\n\nTA::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Central tensor on sublattice A\nTB::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: Central tensor on sublattice B\n\nReferences\n\nYang et. al. Phys. Rev. Letters 118 (2017)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.LoopTNR-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:(TensorKit.AbstractTensorMap{<:Number, <:TensorKit.VectorSpace, 2, 2})","page":"Library","title":"TNRKit.LoopTNR","text":"LoopTNR(\n    unitcell_2x2::Matrix{T},\n    loop_criterion::stopcrit,\n    trunc::TensorKit.TruncationScheme,\n    truncentanglement::TensorKit.TruncationScheme\n) where {T <: AbstractTensorMap{<:Any, <:Any, 2, 2}}\n\nInitialize LoopTNR using a network with 2 x 2 unit cell,  by first performing one round of loop optimization to reduce the network to a bipartite one (without normalization). \n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.SLoopTNR","page":"Library","title":"TNRKit.SLoopTNR","text":"mutable struct SLoopTNR{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 4, 0}} <: TNRScheme{E, S}\n\nc4 & inversion symmetric Loop Optimization for Tensor Network Renormalization\n\nConstructors\n\nSLoopTNR(T)\nSLoopTNR(TA, TB)\n\nRunning the algorithm\n\nrun!(::SLoopTNR, trscheme::TensorKit.TruncationScheme,\n          criterion::TNRKit.stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, oneloop=true,\n          verbosity=1])\n\noneloop=true will use disentangled tensors as a starting guess for the optimization.\n\nFields\n\nT::TensorKit.AbstractTensor{E, S, 4} where {E, S}: Central tensor\ngradalg::OptimKit.LBFGS: Gradient optimization algorithm\n\nReferences\n\nYang et. al. Phys. Rev. Letters 118 (2017) (Fig. S6)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.Sublattice_CTM","page":"Library","title":"TNRKit.Sublattice_CTM","text":"– CTMRG for A-B sublattice systems\n\n┌────┐  ┌───┐  ┌───┐  ┌────┐ │Ctl1├──┤EtB├──┤EtA├──┤Ctr1│ └─┬──┘  └─┬─┘  └─┬─┘  └─┬──┘ ┌─┼──┐  ┌─┼─┐  ┌─┼─┐  ┌─┼──┐ │ElB ├──┤ A ├──┤ B ├──┤ErA │ └─┬──┘  └─┬─┘  └─┬─┘  └─┬──┘ ┌─┼──┐  ┌─┼─┐  ┌─┼─┐  ┌─┼──┐ │ElA ├──┤ B ├──┤ A ├──┤ErB │ └─┬──┘  └─┬─┘  └─┬─┘  └─┬──┘ ┌─┼──┐  ┌─┼─┐  ┌─┼─┐  ┌─┼──┐ │Cbl1├──┤EbA├──┤EbB├──┤Cbr1│ └────┘  └───┘  └───┘  └────┘\n\n┌────┐  ┌───┐  ┌───┐  ┌────┐ │Ctl2├──┤EtA├──┤EtB├──┤Ctr2│ └─┬──┘  └─┬─┘  └─┬─┘  └─┬──┘ ┌─┼──┐  ┌─┼─┐  ┌─┼─┐  ┌─┼──┐ │ElA ├──┤ B ├──┤ A ├──┤ErB │ └─┬──┘  └─┬─┘  └─┬─┘  └─┬──┘ ┌─┼──┐  ┌─┼─┐  ┌─┼─┐  ┌─┼──┐ │ElB ├──┤ A ├──┤ B ├──┤ErA │ └─┬──┘  └─┬─┘  └─┬─┘  └─┬──┘ ┌─┼──┐  ┌─┼─┐  ┌─┼─┐  ┌─┼──┐ │Cbl2├──┤EbB├──┤EbA├──┤Cbr2│ └────┘  └───┘  └───┘  └────┘\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.TRG","page":"Library","title":"TNRKit.TRG","text":"mutable struct TRG{E, S, TT<:TensorKit.AbstractTensorMap{E, S, 2, 2}} <: TNRScheme{E, S}\n\nTensor Renormalization Group\n\nConstructors\n\nTRG(T)\n\nRunning the algorithm\n\nrun!(::TRG, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalizer=default_Finalizer, finalize_beginning=true, verbosity=1])\n\nEach step rescales the lattice by a (linear) factor of √2\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{E, S, 2, 2} where {E, S}: central tensor\n\nReferences\n\nLevin & Nave Phys. Rev. Letters 99(12) (2007)\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.c4vCTM","page":"Library","title":"TNRKit.c4vCTM","text":"mutable struct c4vCTM{A, S, TT<:TensorKit.AbstractTensorMap{A, S, 0, 4}, TC<:TensorKit.AbstractTensorMap{A, S, 1, 1}, TE<:TensorKit.AbstractTensorMap{A, S, 2, 1}} <: TNRScheme{A, S}\n\nC4v symmetric Corner Transfer Matrix Renormalization Group\n\nConstructors\n\nc4vCTM(T)\nc4vCTM(T, [, symmetrize=false])\n\nc4vCTM can be called with a (2,2) tensor (West, South, North, East) with the usual arrow conventions (flipped arrow convention),  or with a (0,4) tensor (North, East, South, West) (unflipped arrow convention). The keyword argument symmetrize makes the tensor C4v symmetric when set to true. If symmetrize = false, it checks the symmetry explicitly.\n\nRunning the algorithm\n\nrun!(::c4vCTM, trunc::TensorKit.TruncationSheme, stop::Stopcrit[, finalize_beginning=true, verbosity=1])\n\ninfo: verbosity levels\n0: No output\n1: Print information at start and end of the algorithm\n2: Print information at each step\n\nFields\n\nT::TensorKit.AbstractTensorMap{A, S, 0, 4} where {A, S}: Central tensor\nC::TensorKit.AbstractTensorMap{A, S, 1, 1} where {A, S}: Corner tensor\nE::TensorKit.AbstractTensorMap{A, S, 2, 1} where {A, S}: Edge tensor\n\n\n\n\n\n","category":"type"},{"location":"lib/lib/#TNRKit.central_charge-Tuple{TNRScheme, Number}","page":"Library","title":"TNRKit.central_charge","text":"central_charge(scheme::TNRScheme, n::Number)\n\nGet the central charge given the current state of a TNRScheme and the previous normalization factor n\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_clock-Tuple{Int64, Float64}","page":"Library","title":"TNRKit.classical_clock","text":"classical_clock(q, β)\n\n\nConstructs the partition function tensor for the classical clock model with q states and a given inverse temperature β.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_ising-Tuple{Number}","page":"Library","title":"TNRKit.classical_ising","text":"classical_ising(β; h)\n\n\nConstructs the partition function tensor for a 2D square lattice for the classical Ising model with a given inverse temperature β and external magnetic field h.\n\nExamples\n\n    classical_ising() # Default inverse temperature is `ising_βc`\n    classical_ising(0.5; h = 1.0) # Custom inverse temperature and magnetic field.\n\nSee also: classical_ising_symmetric, classical_ising_symmetric_3D, classical_ising_3D.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_ising_3D-Tuple{Any}","page":"Library","title":"TNRKit.classical_ising_3D","text":"classical_ising_3D(β; J)\n\n\nConstructs the partition function tensor for a 3D cubic lattice for the classical Ising model with a given inverse temperature β and coupling constant J (by default J = 1.0).\n\nExamples\n\n    classical_ising_3D() # Default inverse temperature is `ising_βc_3D`, coupling constant is `J = 1.0`.\n    classical_ising_3D(0.5; J = 1.0) # Custom inverse temperature and coupling constant.\n\nSee also: classical_ising_symmetric_3D, classical_ising, classical_ising_symmetric.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_ising_impurity-Tuple{Number}","page":"Library","title":"TNRKit.classical_ising_impurity","text":"classical_ising_impurity(β; h)\n\n\nConstructs the partition function tensor for a 2D square lattice for the classical Ising model with a given inverse temperature β and external magnetic field h with a magnetisation impurity\n\nExamples\n\n    classical_ising_impurity() # Default inverse temperature is `ising_βc`\n    classical_ising_impurity(0.5; h = 1.0) # Custom inverse temperature and magnetic field\n\ninfo: Info\nWhen calculating the free energy with free_energy(), set the initial_size keyword argument to 2.0. The initial lattice holds 2 spins.\n\nSee also: classical_ising_symmetric, classical_ising_symmetric_3D, classical_ising_3D.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_ising_symmetric-Tuple{Any}","page":"Library","title":"TNRKit.classical_ising_symmetric","text":"classical_ising_symmetric(β)\n\n\nConstructs the partition function tensor for a symmetric 2D square lattice for the classical Ising model with a given inverse temperature β.\n\nThis tensor has explicit ℤ₂ symmetry on each of it spaces.\n\nExamples\n\n    classical_ising_symmetric() # Default inverse temperature is `ising_βc`\n    classical_ising_symmetric(0.5) # Custom inverse temperature.\n\nSee also: classical_ising, classical_ising_symmetric_3D, classical_ising_3D.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_ising_symmetric_3D-Tuple{Any}","page":"Library","title":"TNRKit.classical_ising_symmetric_3D","text":"classical_ising_symmetric_3D(β)\n\n\nConstructs the partition function tensor for a symmetric 3D cubic lattice for the classical Ising model with a given inverse temperature β.\n\nThis tensor has explicit ℤ₂ symmetry on each of its spaces.\n\nExamples\n\n    classical_ising_symmetric_3D() # Default inverse temperature is `ising_βc_3D`\n    classical_ising_symmetric_3D(0.5) # Custom inverse temperature.\n\nSee also:  classical_ising_3D, classical_ising, classical_ising_symmetric.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_potts-Tuple{Int64, Float64}","page":"Library","title":"TNRKit.classical_potts","text":"classical_potts(q, β)\n\n\nConstructs the partition function tensor for the classical Potts model with q states and a given inverse temperature β.\n\nExamples\n\n    classical_potts(3) # Default inverse temperature is `potts_βc(3)`\n    classical_potts(3, 0.5) # Custom inverse temperature.\n\nSee also: classical_potts_symmetric, potts_βc.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.classical_potts_impurity","page":"Library","title":"TNRKit.classical_potts_impurity","text":"classical_potts_impurity(q, β)\nclassical_potts_impurity(q, β, k1)\nclassical_potts_impurity(q, β, k1, k2)\n\n\nConstructs the partition function tensor for a Potts model with q states and a given inverse temperature β with impurities in sectors k1 and k2.\n\nExamples\n\n    classical_potts_impurity(3) # Default inverse temperature is `potts_βc(3)`\n    classical_potts_impurity(3, 1, 2) # Custom inverse temperature and impurity sectors.\n    classical_potts_impurity(3, 0.5, 2, 3) # Custom inverse temperature and impurity sectors.\n\nSee also: classical_potts, potts_βc.\n\n\n\n\n\n","category":"function"},{"location":"lib/lib/#TNRKit.classical_potts_symmetric-Tuple{Int64, Float64}","page":"Library","title":"TNRKit.classical_potts_symmetric","text":"classical_potts_symmetric(q, β)\n\n\nConstructs the partition function tensor for a symmetric Potts model with q states and a given inverse temperature β.\n\nThis tensor has explicit ℤq symmetry on each of its spaces.\n\nExamples\n\n    classical_potts_symmetric(3) # Default inverse temperature is `potts_βc(3)`\n    classical_potts_symmetric(3, 0.5) # Custom inverse temperature.\n\nSee also: classical_potts, potts_βc.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.free_energy-Tuple{Any, Any}","page":"Library","title":"TNRKit.free_energy","text":"free_energy(data, β; scalefactor, initial_size)\n\n\nTakes a vector of normalization factors data and a given inverse temperature β and computes the free energy.\n\ninfo: Info\nThe scalefactor should be set to the rescaling factor of the area of the tensor network after each iteration of the TNR algorithm.The initial_size should be set to the intial size of the physical lattice, which is typically 1.0.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.gross_neveu_start-Tuple{Number, Number, Number}","page":"Library","title":"TNRKit.gross_neveu_start","text":"gross_neveu_start(μ, m, g)\n\n\nConstructs the partition function tensor for the Gross-Neveu model with given parameters μ, m, and g.\n\nReferences\n\nAkiyama et. al. J. Phys.: Condens. Matter 36 (2024) 343002\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.potts_βc-Tuple{Any}","page":"Library","title":"TNRKit.potts_βc","text":"potts_βc(q)\n\n\nreturns the inverse critical temperature for the classical q-state Potts model on a 2D square lattice.\n\nSee also: classical_potts, classical_potts_symmetric.\n\n\n\n\n\n","category":"method"},{"location":"lib/lib/#TNRKit.sixvertex","page":"Library","title":"TNRKit.sixvertex","text":"sixvertex(elt::Type{<:Number} = Float64, symmetry::Type{<:Sector} = Trivial; a = 1.0, b = 1.0, c = 1.0)\nsixvertex(symmetry::Type{<:Sector}; kwargs...)\n\nConstructs the partition function tensor for the six-vertex model with a given symmetry type and coupling constants a, b, and c.\n\nDefaults\n\n- elt: Float64\n- symmetry: Trivial\n- a: 1.0\n- b: 1.0\n- c: 1.0\n\nExamples\n\n    sixvertex() # Default symmetry is `Trivial`, coupling constants are `a = 1.0`, `b = 1.0`, `c = 1.0`.\n    sixvertex(CU1Irrep) # CU1 symmetry with default coupling constants.\n    sixvertex(ComplexF64, U1Irrep; a = 2.0, b = 3.0, c = 4.0) # U1 symmetry with custom coupling constants and element type.\n\nNote: The free energy density depends on the boundary conditions.  \n\n\n\n\n\n","category":"function"},{"location":"finalizers/#Finalizers","page":"Finalizers","title":"Finalizers","text":"At the end of every TNR step (and before the first step if finalize_beginning=true is chose in the run! function, which is default behaviour), the state of the scheme is finalized.\n\nBy default this finalization process is as follow:\n\nWe calculate the \"norm\" of the scheme's tensor(s) by taking the trace over the lattice directions. To keep the numbers in the tensor(s) from diverging, we divide the tensor(s) by this norm.\n\nFor TRG this is for example:\n\nn = norm(@tensor T[1 2; 2 1])\nT /= n\n\nAt the end of a simulation, the run! function returns a vector of these norms. You can take this data to calculate the free energy through the free_energy(data, β) function for example.\n\nThis finalization is handled through what we call Finalizers.\n\nThese Finalizers are a way for the user to calculate all sorts of things throughout a TNR calculation.\n\nA custom instance of Finalizer can be created as:\n\nfunction my_finalization(scheme::TRG)\n    n = finalize!(scheme) # normalizes the tensor and return said norm\n    data = calculate_something(scheme)\n    return n, data # Two Float64s\nend\n\ncustom_Finalizer = Finalizer(my_finalization, Tuple{Float64, Float64})\n\nAnd can then by used by setting the finalizer kwarg in the run! function:\n\ndata = run!(...; finalizer=custom_Finalizer)\n\nA Finalizer has 1 field f! which is the function being called on the scheme (f!(scheme)) at the time of finalization. It also has a type parameter E that corresponds to the output type of f!. We use this type parameter E to correctly allocate a Vector{E} in which all the data will be stored throughout the simulation.","category":"section"},{"location":"finalizers/#Examples","page":"Finalizers","title":"Examples","text":"The default Finalizer is default_Finalizer which normalizes the tensor(s) and stores the norm. For the impurity methods (ImpurityTRG and ImpurityHOTRG) the defaults are ImpurityTRG_Finalizer and ImpurityHOTRG_Finalizer respectively, as these methods usually require us to store more than just one norm per iteration.\n\nTRG, ATRG, HOTRG and BTRG can be normalized by calculating the norm of a 2x2 patch of tensors, which is more computationally expensive but should™ be more stable. We provide a two_by_two_Finalizer to use this.\n\nWe plan to provide cft data finalizers as well, as soon as we streamline the cft data generation for all the provided TNR schemes.","category":"section"},{"location":"#TNRKit","page":"Home","title":"TNRKit","text":"Your one-stop-shop for Tensor Network Renormalization.","category":"section"},{"location":"#Package-summary","page":"Home","title":"Package summary","text":"TNRKit.jl aims to provide as many Tensor Network Renormalization methods as possible. Several models like the classical Ising, Potts and Six Vertex models are provided.\n\nYou can use TNRKit for calculating:\n\nPartition functions (classical & quantum)\nCFT data\nCentral charges\n\nMany common TNR schemes have already been implemented:\n\n2D square tensor networks\n\nTRG (Levin and Nave's Tensor Renormalization Group)\nBTRG (bond-weighted TRG)\nLoopTNR (entanglement filtering + loop optimization)\nSLoopTNR (c4 & inversion symmetric LoopTNR)\nHOTRG (higher order TRG)\nATRG (anisotropic TRG)\n\nCTM methods (yet to be documented)\n\nctm_TRG (Corner Transfer Matrix environment + TRG)\nctm_HOTRG (Corner Transfer Matrix environment + HOTRG)\nc4vCTM (c4v symmetric CTM)\nrCTM (reflection symmetric CTM)\n\nImpurity Methods\n\nImpurityTRG\nImpurityHOTRG\n\n3D cubic tensor networks\n\nATRG_3D (anisotropic TRG)\nHOTRG_3D (higher order TRG)","category":"section"},{"location":"#Quick-Start-Guide","page":"Home","title":"Quick Start Guide","text":"Choose a (TensorKit!) tensor that respects the leg-convention (see below)\nChoose a TNR scheme\nChoose a truncation scheme\nChoose a stopping criterion\n\nFor example:\n\nusing TNRKit, TensorKit\n\nT = classical_ising_symmetric(ising_βc) # partition function of classical Ising model at the critical point\nscheme = BTRG(T) # Bond-weighted TRG (excellent choice)\ndata = run!(scheme, truncdim(16), maxiter(25)) # max bond-dimension of 16, for 25 iterations\n\ndata now contains 26 norms of the tensor, 1 for every time the tensor was normalized. (By default there is a normalization step before the first coarse-graining step wich can be turned off by changing the kwarg run!(...; finalize_beginning=false))\n\nUsing these norms you could, for example, calculate the free energy of the critical classical Ising model:\n\nf = free_energy(data, ising_βc) # -2.1096504926141826902647832\n\nYou could even compare to the exact value, as calculated by the Onsager solution:\n\njulia> abs((f - f_onsager) / f_onsager)\n3.1e-07\n\nPretty impressive for a calculation that takes about 0.3s on a laptop.","category":"section"},{"location":"#Verbosity","page":"Home","title":"Verbosity","text":"There are 3 levels of verbosity implemented in TNRKit:\n\nLevel 0: no TNRKit messages whatsoever.\nLevel 1: Info at beginning and end of the simulations (including information on why the simulation stopped, how long it took and how many iterations were performed).\nLevel 2: Level 1 + info at every iteration about the last generated finalize output and the iteration number.\n\nto choose the verbosity level, simply use run!(...; verbosity=n). The default is verbosity=1.","category":"section"},{"location":"#Included-Models","page":"Home","title":"Included Models","text":"TNRKit includes several common models out of the box.\n\nIsing model: classical_ising and classical_ising_symmetric, which has a Z2 grading on each leg.\nPotts model: classical_potts and classical_potts_symmetric, which has a Zq grading on each leg.\nSix Vertex model: sixvertex\nClock model: classical_clock\n\nIf you want to implement your own model you must respect the leg-convention assumed by all TNRKit schemes.","category":"section"},{"location":"#Leg-convention","page":"Home","title":"Leg-convention","text":"All the schemes assume that the input tensor lives in the space V_1 otimes V_2 leftarrow V_3 otimes V_4 and that the legs are ordered in the following way:\n\n     3\n     |\n     v\n     |\n1-<--┼--<-4\n     |\n     v\n     |\n     2\n\nThe 3D scheme(s) assume that the input tensor lives in the space V_textD otimes V_textU prime leftarrow V_textN otimes V_textE otimes V_textS prime otimes V_textW prime.\n\nWhere D, U, N, E, S, W stand for Down, Up, North, East, South and West.","category":"section"}]
}
